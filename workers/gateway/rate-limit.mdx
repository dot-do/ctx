---
$type: Worker::Function
$id: worker/gateway/rate-limit
worker: gateway
function: rateLimit
description: Enforce rate limits per user or IP address to prevent abuse
---

# Rate Limiting Middleware

## Purpose

Prevent API abuse by limiting the number of requests per time window, with different limits for different routes and authentication states.

## Rate Limit Configuration

### Default Limits

```typescript
const DEFAULT_CONFIG: RateLimitConfig = {
  windowMs: 60 * 1000,    // 1 minute
  maxRequests: 60,        // 60 requests per minute
}
```

### Route-Specific Limits

Stricter limits for expensive operations:

```typescript
const ROUTE_LIMITS: Record<string, RateLimitConfig> = {
  '/ai/':        { windowMs: 60000, maxRequests: 20 },  // AI operations
  '/batch/':     { windowMs: 60000, maxRequests: 5 },   // Batch operations
  '/workflows/': { windowMs: 60000, maxRequests: 30 },  // Workflows
  '/auth/':      { windowMs: 60000, maxRequests: 10 },  // Auth operations
}
```

## Identifier Strategy

Rate limits are tracked per:

1. **Authenticated Users** - `user:{userId}` (higher limits)
2. **Anonymous Users** - `ip:{ipAddress}` (lower limits)

```typescript
function getRateLimitIdentifier(request: Request, ctx: GatewayContext): string {
  // Use userId if authenticated
  if (ctx.auth?.userId) {
    return `user:${ctx.auth.userId}`
  }

  // Use IP address for anonymous users
  const ip = request.headers.get('CF-Connecting-IP') ||
             request.headers.get('X-Forwarded-For') ||
             'unknown'
  return `ip:${ip}`
}
```

## Storage Backends

### KV Storage (Production)

Distributed rate limiting across workers:

```typescript
async function checkRateLimitKV(
  identifier: string,
  config: RateLimitConfig,
  kv: KVNamespace
): Promise<RateLimitResult> {
  const now = Date.now()
  const key = `ratelimit:${identifier}`

  // Get current count
  const recordStr = await kv.get(key)
  const record = recordStr ? JSON.parse(recordStr) : null

  if (!record || record.resetAt < now) {
    // Reset the rate limit
    const resetAt = now + config.windowMs
    const newRecord = { count: 1, resetAt }

    await kv.put(key, JSON.stringify(newRecord), {
      expirationTtl: Math.ceil(config.windowMs / 1000),
    })

    return { allowed: true, remaining: config.maxRequests - 1, resetAt }
  }

  if (record.count >= config.maxRequests) {
    return { allowed: false, remaining: 0, resetAt: record.resetAt }
  }

  // Increment count
  record.count++
  await kv.put(key, JSON.stringify(record), {
    expirationTtl: Math.ceil((record.resetAt - now) / 1000),
  })

  return {
    allowed: true,
    remaining: config.maxRequests - record.count,
    resetAt: record.resetAt,
  }
}
```

### In-Memory Storage (Development)

Simple Map-based storage for local development:

```typescript
const rateLimitStore = new Map<string, { count: number; resetAt: number }>()

function checkRateLimitMemory(
  identifier: string,
  config: RateLimitConfig
): RateLimitResult {
  const now = Date.now()
  const record = rateLimitStore.get(identifier)

  if (!record || record.resetAt < now) {
    const resetAt = now + config.windowMs
    rateLimitStore.set(identifier, { count: 1, resetAt })
    return { allowed: true, remaining: config.maxRequests - 1, resetAt }
  }

  if (record.count >= config.maxRequests) {
    return { allowed: false, remaining: 0, resetAt: record.resetAt }
  }

  record.count++
  return {
    allowed: true,
    remaining: config.maxRequests - record.count,
    resetAt: record.resetAt,
  }
}
```

## Implementation

```typescript
export async function rateLimit(
  request: Request,
  ctx: GatewayContext
): Promise<Response | null> {
  const url = new URL(request.url)
  const config = getRateLimitConfig(url.pathname)
  const identifier = getRateLimitIdentifier(request, ctx)

  // Use KV if available, otherwise use memory
  const result = ctx.env.GATEWAY_KV
    ? await checkRateLimitKV(identifier, config, ctx.env.GATEWAY_KV)
    : checkRateLimitMemory(identifier, config)

  if (!result.allowed) {
    return Response.json(
      {
        error: 'Too many requests',
        message: 'Rate limit exceeded. Please try again later.',
        retryAfter: Math.ceil((result.resetAt - Date.now()) / 1000),
      },
      {
        status: 429,
        headers: {
          'Retry-After': String(Math.ceil((result.resetAt - Date.now()) / 1000)),
          'X-RateLimit-Limit': String(config.maxRequests),
          'X-RateLimit-Remaining': String(result.remaining),
          'X-RateLimit-Reset': String(Math.floor(result.resetAt / 1000)),
        },
      }
    )
  }

  // Rate limit passed
  return null
}
```

## Response Headers

All responses include rate limit headers:

```
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 45
X-RateLimit-Reset: 1704067200
```

When rate limited (429):

```
Retry-After: 30
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1704067200
```

## Admin Bypass

Admins bypass rate limits:

```typescript
if (ctx.auth?.role === 'admin') {
  return null  // Skip rate limiting
}
```

## Clear Rate Limit

Admin-only function to clear rate limits:

```typescript
export async function clearRateLimit(
  identifier: string,
  ctx: GatewayContext
): Promise<void> {
  if (ctx.env.GATEWAY_KV) {
    await ctx.env.GATEWAY_KV.delete(`ratelimit:${identifier}`)
  } else {
    rateLimitStore.delete(identifier)
  }
}
```

## Error Response

When rate limited:

```json
{
  "error": "Too many requests",
  "message": "Rate limit exceeded. Please try again later.",
  "retryAfter": 30
}
```

## Tests

```typescript
describe('Rate Limiting', () => {
  it('allows requests within limit', async () => {
    const response = await rateLimit(request, ctx)
    expect(response).toBeNull()
  })

  it('blocks requests exceeding limit', async () => {
    // Exhaust rate limit
    for (let i = 0; i < 60; i++) {
      await rateLimit(request, ctx)
    }

    // Next request should be blocked
    const response = await rateLimit(request, ctx)
    expect(response?.status).toBe(429)
  })

  it('resets after time window', async () => {
    // Exhaust rate limit
    for (let i = 0; i < 60; i++) {
      await rateLimit(request, ctx)
    }

    // Wait for window to reset
    await new Promise(resolve => setTimeout(resolve, 60000))

    // Should be allowed again
    const response = await rateLimit(request, ctx)
    expect(response).toBeNull()
  })
})
```

## Related

- [types.ts](./types.mdx) - RateLimitConfig type
- [wrangler.jsonc](../../../workers/gateway/wrangler.jsonc) - KV namespace configuration
