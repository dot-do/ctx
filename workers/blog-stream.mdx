---
$type: Worker
$id: blog-stream
name: blog-stream
main: src/index.ts
compatibility_date: "2025-01-08"
account_id: b6641681fe423910342b9ffa1364c76d

observability:
  enabled: true

services:
  - binding: DB_SERVICE
    service: db
  - binding: AI_SERVICE
    service: ai
  - binding: DEPLOY_SERVICE
    service: deploy

routes:
  - pattern: blog.apis.do/*
    zone_name: apis.do

tail_consumers:
  - service: pipeline
---

# Blog Stream Worker

AI-powered blog post generation with streaming responses and automatic database caching.

## Overview

This worker generates blog posts on-demand using AI when they're not found in the database. It streams the generation in real-time using Server-Sent Events (SSE), providing instant feedback to users while saving generated posts for future requests.

## Features

- ✅ **On-Demand Generation** - Generate blog posts on-the-fly when not found in DB
- ✅ **Streaming Responses** - Server-Sent Events (SSE) for real-time content streaming
- ✅ **Safety Validation** - Comprehensive title validation (SQL injection, XSS, path traversal)
- ✅ **AI Service Integration** - Uses AI service via RPC with GPT-OSS 120B model
- ✅ **Database Integration** - Automatic caching of generated posts
- ✅ **RPC Interface** - Service-to-service communication support
- ✅ **Fire-and-Forget Saves** - Non-blocking database operations
- ✅ **Observability** - Tail consumers for monitoring and analytics

## Architecture

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │ GET /blog/hello-world
       ▼
┌─────────────────┐
│  Blog Stream    │ ◄── Check DB_SERVICE
│     Worker      │
└────────┬────────┘
         │
         ├── Found? → Return cached post
         │
         └── Not found?
                    │
                    ├── Validate title safety
                    │
                    ├── Call AI_SERVICE.generateStream() (RPC)
                    │   └── Workers AI GPT-OSS 120B
                    │
                    ├── Stream response to client (SSE)
                    └── Save to DB (fire & forget)
```

## API

### HTTP Endpoints

#### `GET /`

Health check endpoint.

**Response:**
```json
{
  "service": "blog-stream",
  "version": "1.0.0",
  "status": "ready"
}
```

#### `GET /blog/:slug`

Get or generate a blog post. Returns existing post from DB or streams AI-generated content.

**Parameters:**
- `slug` - URL-safe blog post identifier (e.g., `hello-world`, `getting-started-with-ai`)

**Response (Existing Post):**
```json
{
  "source": "database",
  "post": {
    "id": "hello-world",
    "slug": "hello-world",
    "title": "Hello World",
    "content": "# Hello World\n\n...",
    "excerpt": "Welcome to...",
    "author": "AI Generated",
    "published_at": "2025-01-08T00:00:00Z",
    "created_at": "2025-01-08T00:00:00Z",
    "updated_at": "2025-01-08T00:00:00Z"
  }
}
```

**Response (Streaming Generation):**

Server-Sent Events (SSE) stream:

```
data: {"type":"start","title":"Hello World","slug":"hello-world","generating":true}

data: {"type":"content","text":"# Hello World\n\n"}

data: {"type":"content","text":"Welcome to this blog post..."}

data: {"type":"complete","slug":"hello-world","title":"Hello World","contentLength":1234}
```

**Error Response:**
```json
{
  "error": "Invalid blog post title",
  "reason": "Title contains XSS patterns"
}
```

### RPC Interface

The worker exports a `BlogStreamService` class that can be called via RPC:

```ts
// Generate blog post via RPC
const result = await env.BLOG_STREAM_SERVICE.generatePost('hello-world')

if (result.success) {
  console.log('Generated:', result.post.title)
  console.log('Content length:', result.post.content.length)
} else {
  console.error('Failed:', result.error)
}

// Check if post exists
const exists = await env.BLOG_STREAM_SERVICE.postExists('hello-world')
console.log('Post exists:', exists)
```

## Safety Checks

The worker validates blog post slugs against multiple attack vectors:

- **SQL Injection** - Blocks `'`, `"`, `;`, `\` characters
- **XSS** - Blocks `<script>`, `<iframe>`, `javascript:`, `onerror=`
- **Path Traversal** - Blocks `..`, `//` patterns
- **Command Injection** - Blocks `;`, `&`, `|`, `` ` ``, `$`, `()` characters
- **Length Validation** - Max 200 characters
- **Empty Slugs** - Rejects empty or dash-only slugs

## AI Integration

Uses the **AI service** via RPC with **GPT-OSS 120B** (`@cf/openai/gpt-oss-120b`) model.

**Architecture:**
```
blog-stream → AI_SERVICE (RPC) → Workers AI GPT-OSS 120B
```

**Benefits:**
- ✅ Microservices architecture - AI logic centralized
- ✅ Multi-provider support (OpenAI, Anthropic, Workers AI)
- ✅ Automatic fallback between providers
- ✅ Fast streaming responses via RPC
- ✅ Cost-effective at scale (Workers AI default)
- ✅ High-quality blog content (120B parameter model)
- ✅ GPT-style architecture
- ✅ Usage tracking and cost calculation

No API keys required for Workers AI - the AI service handles all provider configuration.

## Implementation

```typescript
/**
 * Blog Stream Worker
 *
 * Streams AI-generated blog posts on-demand when not found in DB
 * Route pattern: /blog/:slug
 */

import { Hono } from 'hono'
import { WorkerEntrypoint } from 'cloudflare:workers'
import { stream, streamText } from 'hono/streaming'

interface Env {
  DB_SERVICE: any
  AI_SERVICE: any
}

interface BlogPost {
  id: string
  slug: string
  title: string
  content: string
  excerpt?: string
  author?: string
  published_at?: string
  created_at: string
  updated_at: string
}

// Safety check for blog post titles
function isSafeTitle(slug: string): { safe: boolean; reason?: string } {
  // Check for SQL injection patterns
  if (/['";\\]/i.test(slug)) {
    return { safe: false, reason: 'Title contains SQL injection patterns' }
  }

  // Check for XSS patterns
  if (/<script|<iframe|javascript:|onerror=/i.test(slug)) {
    return { safe: false, reason: 'Title contains XSS patterns' }
  }

  // Check for path traversal
  if (/\.\.|\/\//i.test(slug)) {
    return { safe: false, reason: 'Title contains path traversal patterns' }
  }

  // Check for command injection
  if (/[;&|`$()]/i.test(slug)) {
    return { safe: false, reason: 'Title contains command injection patterns' }
  }

  // Check length (reasonable blog post title)
  if (slug.length > 200) {
    return { safe: false, reason: 'Title too long (max 200 characters)' }
  }

  // Check if it's just dashes or empty
  if (!slug.replace(/-/g, '').trim()) {
    return { safe: false, reason: 'Title is empty or only contains dashes' }
  }

  return { safe: true }
}

// Convert slug to human-readable title
function slugToTitle(slug: string): string {
  return slug
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

// Generate blog post content using AI
async function generateBlogPost(env: Env, title: string): Promise<ReadableStream> {
  const prompt = `Write a comprehensive, engaging blog post about "${title}".

Structure:
- Start with a compelling introduction
- Include 3-4 main sections with practical insights
- Use markdown formatting (headers, lists, code blocks where appropriate)
- End with a conclusion and key takeaways

Tone: Professional but conversational
Length: ~800-1200 words
Format: Markdown`

  // Use AI service with Workers AI GPT-OSS 120B model
  return env.AI_SERVICE.generateStream(prompt, {
    provider: 'workers-ai',
    model: '@cf/openai/gpt-oss-120b'
  })
}

const app = new Hono<{ Bindings: Env }>()

// Health check
app.get('/', (c) => {
  return c.json({
    service: 'blog-stream',
    version: '1.0.0',
    status: 'ready'
  })
})

// Blog post route with streaming generation
app.get('/blog/:slug', async (c) => {
  const slug = c.req.param('slug')

  // Validate title safety first
  const safetyCheck = isSafeTitle(slug)
  if (!safetyCheck.safe) {
    return c.json({
      error: 'Invalid blog post title',
      reason: safetyCheck.reason
    }, 400)
  }

  // Check if blog post exists in DB
  try {
    const existing = await c.env.DB_SERVICE.query({
      ns: 'blog.posts',
      type: 'BlogPost',
      filter: { slug }
    })

    if (existing?.data?.length > 0) {
      // Return existing post
      const post = existing.data[0]
      return c.json({
        source: 'database',
        post
      })
    }
  } catch (error) {
    console.error('Database check error:', error)
    // Continue to generation if DB check fails
  }

  // Generate blog post with streaming
  const title = slugToTitle(slug)

  return stream(c, async (stream) => {
    // Send initial metadata
    await stream.write(`data: ${JSON.stringify({
      type: 'start',
      title,
      slug,
      generating: true
    })}\n\n`)

    try {
      // Generate content stream
      const contentStream = await generateBlogPost(c.env, title)
      const reader = contentStream.getReader()
      const decoder = new TextDecoder()

      let fullContent = ''

      while (true) {
        const { done, value } = await reader.read()

        if (done) break

        const chunk = decoder.decode(value, { stream: true })

        // Workers AI streaming format - chunks are text
        fullContent += chunk
        await stream.write(`data: ${JSON.stringify({
          type: 'content',
          text: chunk
        })}\n\n`)
      }

      // Save to database (fire and forget)
      if (fullContent) {
        c.env.DB_SERVICE.upsert({
          ns: 'blog.posts',
          type: 'BlogPost',
          id: slug,
          data: {
            slug,
            title,
            content: fullContent,
            excerpt: fullContent.split('\n\n')[0].slice(0, 200) + '...',
            author: 'AI Generated',
            published_at: new Date().toISOString(),
            generated: true
          }
        }).catch((err: Error) => console.error('Failed to save to DB:', err))
      }

      // Send completion
      await stream.write(`data: ${JSON.stringify({
        type: 'complete',
        slug,
        title,
        contentLength: fullContent.length
      })}\n\n`)

    } catch (error) {
      console.error('Generation error:', error)
      await stream.write(`data: ${JSON.stringify({
        type: 'error',
        error: error instanceof Error ? error.message : 'Unknown error'
      })}\n\n`)
    }
  })
})

// RPC interface for service-to-service calls
export class BlogStreamService extends WorkerEntrypoint<Env> {
  /**
   * Generate a blog post by slug
   */
  async generatePost(slug: string): Promise<{ success: boolean; post?: BlogPost; error?: string }> {
    const safetyCheck = isSafeTitle(slug)
    if (!safetyCheck.safe) {
      return { success: false, error: safetyCheck.reason }
    }

    try {
      // Check DB first
      const existing = await this.env.DB_SERVICE.query({
        ns: 'blog.posts',
        type: 'BlogPost',
        filter: { slug }
      })

      if (existing?.data?.length > 0) {
        return { success: true, post: existing.data[0] }
      }

      // Generate content
      const title = slugToTitle(slug)
      const contentStream = await generateBlogPost(this.env, title)
      const reader = contentStream.getReader()
      const decoder = new TextDecoder()

      let fullContent = ''

      while (true) {
        const { done, value } = await reader.read()
        if (done) break
        fullContent += decoder.decode(value, { stream: true })
      }

      // Save to DB
      const post: BlogPost = {
        id: slug,
        slug,
        title,
        content: fullContent,
        excerpt: fullContent.split('\n\n')[0].slice(0, 200) + '...',
        author: 'AI Generated',
        published_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }

      await this.env.DB_SERVICE.upsert({
        ns: 'blog.posts',
        type: 'BlogPost',
        id: slug,
        data: post
      })

      return { success: true, post }

    } catch (error) {
      console.error('Generate post error:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  }

  /**
   * Check if a blog post exists
   */
  async postExists(slug: string): Promise<boolean> {
    try {
      const result = await this.env.DB_SERVICE.query({
        ns: 'blog.posts',
        type: 'BlogPost',
        filter: { slug }
      })
      return result?.data?.length > 0
    } catch (error) {
      console.error('Post exists check error:', error)
      return false
    }
  }

  /**
   * HTTP fetch handler
   */
  override fetch(request: Request): Response | Promise<Response> {
    return app.fetch(request, this.env)
  }
}

export default BlogStreamService
```

## Usage Examples

### Client-Side (EventSource)

```js
const eventSource = new EventSource('/blog/hello-world')

eventSource.addEventListener('message', (event) => {
  const data = JSON.parse(event.data)

  switch (data.type) {
    case 'start':
      console.log('Generation started:', data.title)
      break

    case 'content':
      // Append content to UI
      document.getElementById('content').textContent += data.text
      break

    case 'complete':
      console.log('Generation complete')
      eventSource.close()
      break

    case 'error':
      console.error('Error:', data.error)
      eventSource.close()
      break
  }
})
```

### Server-Side (RPC)

```ts
// From another worker
const post = await env.BLOG_STREAM_SERVICE.generatePost('ai-best-practices')

if (post.success) {
  console.log('Generated:', post.post.title)
  console.log('Content length:', post.post.content.length)
} else {
  console.error('Failed:', post.error)
}
```

### Fetch API (Manual Stream)

```ts
const response = await fetch('https://blog.apis.do/blog/hello-world')
const reader = response.body.getReader()
const decoder = new TextDecoder()

while (true) {
  const { done, value } = await reader.read()
  if (done) break

  const chunk = decoder.decode(value)
  const lines = chunk.split('\n')

  for (const line of lines) {
    if (line.startsWith('data: ')) {
      const data = JSON.parse(line.slice(6))
      console.log('Event:', data)
    }
  }
}
```

## Database Schema

Posts are stored in the `blog.posts` namespace with type `BlogPost`:

```ts
interface BlogPost {
  id: string           // Same as slug
  slug: string         // URL-safe identifier
  title: string        // Human-readable title
  content: string      // Full markdown content
  excerpt?: string     // First 200 characters + "..."
  author?: string      // "AI Generated"
  published_at?: string  // ISO 8601 timestamp
  created_at: string   // ISO 8601 timestamp
  updated_at: string   // ISO 8601 timestamp
}
```

## Service Bindings

- `DB_SERVICE` - Database service for post storage/retrieval
- `AI_SERVICE` - AI service for content generation (via RPC)
- `DEPLOY_SERVICE` - Deploy API (for observability)

## Performance

- **Cached Posts**: <50ms response time
- **New Generation**: 3-8 seconds (streaming starts immediately)
- **Database Saves**: Async, non-blocking
- **Concurrent Requests**: Unlimited (stateless)

## Error Handling

- Invalid slugs return 400 with reason
- DB errors gracefully degrade to generation
- AI errors stream error event
- Saves fail silently (logged)

## Monitoring

All requests are logged to the `pipeline` service via tail consumers for:
- Request patterns
- Generation times
- Error rates
- Cache hit/miss ratios

## Development

```bash
# Install dependencies
pnpm install

# Start local dev server
pnpm dev

# Type check
pnpm typecheck

# Deploy to production
pnpm deploy
```

## Testing

```bash
# Health check
curl http://localhost:8788/

# Get existing post
curl http://localhost:8788/blog/hello-world

# Generate new post (streaming)
curl http://localhost:8788/blog/ai-best-practices
```

## Future Enhancements

- [ ] Support multiple languages
- [ ] Custom style/tone preferences
- [ ] Image generation integration
- [ ] SEO metadata generation
- [ ] Related posts suggestions
- [ ] Content versioning
- [ ] A/B testing different AI prompts

## Related Workers

- `db` - Database service for post storage
- `ai` - AI service for content generation
- `gateway` - API gateway for routing
- `pipeline` - Observability and logging

## Dependencies

- `hono` - Web framework
- `cloudflare:workers` - Worker entrypoint
- `hono/streaming` - SSE streaming utilities

## Tech Stack

- **Hono** - Fast web framework
- **Workers AI** - GPT-OSS 120B model
- **RPC** - Service-to-service communication
- **SSE** - Server-Sent Events for streaming
- **TypeScript** - Type-safe development

---

**Generated from:** blog-stream.mdx

**Build command:** `tsx scripts/build-mdx-worker.ts blog-stream.mdx`
