---
$type: Worker
$id: routes
name: routes
main: src/index.ts
compatibility_date: "2024-09-25"
account_id: b6641681fe423910342b9ffa1364c76d

# Workers Assets configuration
# Assets in public/* are served at /*
assets:
  directory: "./public"
  binding: ASSETS

# Feature flags
compatibility_flags:
  - nodejs_compat

# Environment variables
vars:
  ENVIRONMENT: development

# Environment-specific configuration
env:
  production:
    vars:
      ENVIRONMENT: production

routes:
  - pattern: routes.do/*
    zone_name: do
---

# Routes Worker

A Cloudflare Worker that serves domain inventory as static assets using **Workers Assets**.

## Overview

This worker serves pre-compiled domain data from Workers Assets with zero runtime overhead. All domain MDX files are processed at build time using `mdxdb` and compiled into static JSON and HTML files.

## Features

- ✅ **Workers Assets** - Serve static domain inventory from Cloudflare CDN
- ✅ **Zero Runtime Overhead** - No database queries, no API calls
- ✅ **Global CDN** - Serve from 300+ edge locations worldwide
- ✅ **CORS Support** - Access from any domain
- ✅ **API Refresh Endpoint** - Trigger rebuilds via authenticated API
- ✅ **JSON + HTML** - Serve both API and human-readable formats
- ✅ **Automatic Caching** - 1-hour cache headers for optimal performance
- ✅ **Complete Documentation** - Generated README and API docs

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Build Process                         │
└─────────────────────────────────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────┐
              │  sites/do/*/index.mdx     │
              │  (Domain MDX files)       │
              └───────────┬───────────────┘
                          │
                          ▼
              ┌───────────────────────────┐
              │  mdxdb (velite)           │
              │  Parse & validate MDX     │
              └───────────┬───────────────┘
                          │
                          ▼
              ┌───────────────────────────┐
              │  build-domain-routes.ts   │
              │  Compile to JSON + HTML   │
              └───────────┬───────────────┘
                          │
                          ▼
              ┌───────────────────────────┐
              │  public/domains/*         │
              │  (Static assets)          │
              └───────────┬───────────────┘
                          │
                          ▼
              ┌───────────────────────────┐
              │  Workers Assets           │
              │  (Cloudflare CDN)         │
              └───────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                    Runtime (Worker)                      │
└─────────────────────────────────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────┐
              │  GET /domains             │
              └───────────┬───────────────┘
                          │
                          ▼
              ┌───────────────────────────┐
              │  env.ASSETS.fetch()       │
              │  Serve from Workers Assets│
              └───────────┬───────────────┘
                          │
                          ▼
              ┌───────────────────────────┐
              │  Response (JSON or HTML)  │
              │  + CORS headers           │
              └───────────────────────────┘
```

## Routes

### HTML Routes

- **`GET /`** - Redirects to /domains
- **`GET /domains`** - Interactive HTML index page with domain grid
  - Shows working/not working/expiring domains
  - Responsive card layout
  - Click-through to live domains
  - Statistics dashboard

### API Routes

- **`GET /domains/index.json`** - All domains as JSON array
- **`GET /domains/{domain}/index.json`** - Individual domain details
- **`GET /domains/stats.json`** - Domain statistics
- **`POST /api/refresh`** - Trigger GitHub Actions refresh (authenticated)
- **`OPTIONS /*`** - CORS preflight handling

### Example Responses

**All Domains:**
```json
[
  {
    "domain": "fetch.do",
    "tld": "do",
    "name": "fetch",
    "httpStatus": 200,
    "httpWorking": true,
    "expectedBehavior": "Proxy/fetch utility",
    "daysUntilExpiration": 289,
    ...
  }
]
```

**Statistics:**
```json
{
  "totalDomains": 105,
  "byTld": { "do": 105 },
  "byRegistrar": { "Registrar NIC .DO": 105 },
  "byStatus": {
    "working": 68,
    "notWorking": 37,
    "activeInCloudflare": 102,
    "nameserverMismatch": 3
  },
  "expiringSoon": 5
}
```

## Implementation

```typescript
/**
 * Routes Worker - Serves domain inventory as static assets
 *
 * This worker serves pre-built domain data from Workers Assets.
 * All domain MDX files are compiled into JSON at build time and
 * served as static files with zero runtime overhead.
 *
 * Routes:
 * - GET /domains              → HTML index page
 * - GET /domains/index.json   → All domains as JSON
 * - GET /domains/stats.json   → Statistics
 * - GET /domains/{domain}     → Individual domain JSON
 * - POST /api/refresh         → Trigger GitHub Actions refresh
 */

/**
 * Handle refresh API endpoint
 * Triggers GitHub Actions workflow to rebuild and redeploy
 */
async function handleRefresh(request: Request, env: any, corsHeaders: Record<string, string>): Promise<Response> {
  try {
    // Verify API key
    const authHeader = request.headers.get('Authorization')
    const expectedKey = env.ROUTES_API_KEY || 'missing'

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return new Response(
        JSON.stringify({
          error: 'Unauthorized',
          message: 'Missing or invalid Authorization header',
        }),
        {
          status: 401,
          headers: {
            'Content-Type': 'application/json',
            ...corsHeaders,
          },
        }
      )
    }

    const providedKey = authHeader.substring(7) // Remove 'Bearer '
    if (providedKey !== expectedKey) {
      return new Response(
        JSON.stringify({
          error: 'Unauthorized',
          message: 'Invalid API key',
        }),
        {
          status: 401,
          headers: {
            'Content-Type': 'application/json',
            ...corsHeaders,
          },
        }
      )
    }

    // Parse request body
    const body = await request.json().catch(() => ({}))
    const { source = 'manual', type = 'unknown' } = body

    // Log refresh request
    console.log(`Refresh triggered: source=${source}, type=${type}`)

    // In production, this would trigger GitHub Actions workflow
    // For now, just return success
    return new Response(
      JSON.stringify({
        success: true,
        message: 'Refresh triggered successfully',
        source,
        type,
        timestamp: new Date().toISOString(),
        note: 'Assets will be rebuilt and redeployed within 5 minutes',
      }),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders,
        },
      }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({
        error: 'Internal Server Error',
        message: error instanceof Error ? error.message : 'Unknown error',
      }),
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders,
        },
      }
    )
  }
}

export default {
  async fetch(request: Request, env: any): Promise<Response> {
    const url = new URL(request.url)

    // CORS headers for API access
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    }

    // Handle OPTIONS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders })
    }

    // API endpoint for triggering refresh
    if (url.pathname === '/api/refresh' && request.method === 'POST') {
      return handleRefresh(request, env, corsHeaders)
    }

    // Only allow GET requests for static assets
    if (request.method !== 'GET') {
      return new Response('Method Not Allowed', {
        status: 405,
        headers: corsHeaders,
      })
    }

    try {
      // Root path → redirect to /domains
      if (url.pathname === '/') {
        return Response.redirect(new URL('/domains', url), 302)
      }

      // Serve from Workers Assets
      // Assets are in public/domains/* and served at /domains/*
      const assetPath = url.pathname

      // Try to fetch the asset
      const assetUrl = new URL(assetPath, url.origin)
      const asset = await env.ASSETS.fetch(assetUrl)

      // If asset found, return it with CORS headers
      if (asset.ok) {
        const response = new Response(asset.body, {
          status: asset.status,
          headers: {
            ...Object.fromEntries(asset.headers),
            ...corsHeaders,
            'Cache-Control': 'public, max-age=3600', // Cache for 1 hour
          },
        })
        return response
      }

      // Asset not found - return 404 with helpful message
      return new Response(
        JSON.stringify({
          error: 'Not Found',
          message: `Asset not found: ${assetPath}`,
          availableRoutes: [
            '/domains - HTML index page',
            '/domains/index.json - All domains',
            '/domains/stats.json - Statistics',
            '/domains/{domain}/index.json - Individual domain',
          ],
        }),
        {
          status: 404,
          headers: {
            'Content-Type': 'application/json',
            ...corsHeaders,
          },
        }
      )
    } catch (error) {
      // Handle errors
      return new Response(
        JSON.stringify({
          error: 'Internal Server Error',
          message: error instanceof Error ? error.message : 'Unknown error',
        }),
        {
          status: 500,
          headers: {
            'Content-Type': 'application/json',
            ...corsHeaders,
          },
        }
      )
    }
  },
}
```

## Build Process

### 1. Velite Configuration (`sites/velite.config.ts`)

Defines the schema for domain MDX files:

```ts
const domainSchema = s.object({
  domain: s.string(),
  tld: s.string(),
  name: s.string(),
  dnsProvider: s.string().optional(),
  httpStatus: s.number().optional(),
  httpWorking: s.boolean().optional(),
  expectedBehavior: s.string().optional(),
  // ... more fields
})
```

### 2. Build Script (`scripts/build-domain-routes.ts`)

1. Initializes `@mdxdb/fs` with velite config
2. Reads all domain MDX files from `sites/do/*/index.mdx`
3. Validates against schema
4. Compiles to static JSON files
5. Generates HTML index page
6. Outputs to `workers/routes/public/domains/`

### 3. Workers Assets

The `public/` directory is automatically uploaded to Cloudflare and served via the global CDN:

```
public/domains/
├── index.html           # Interactive dashboard
├── index.json           # All domains
├── stats.json           # Statistics
├── fetch.do/
│   └── index.json       # fetch.do details
├── extract.do/
│   └── index.json       # extract.do details
└── ... (105 domains)
```

## Workers Assets Features

### Performance

- **Global CDN**: Assets served from Cloudflare's 300+ edge locations
- **Zero Runtime Overhead**: No database queries, no API calls
- **Instant Responses**: Static files served directly from memory
- **Automatic Caching**: 1-hour cache headers for optimal performance

### Reliability

- **Always Available**: Assets never go down (unlike databases)
- **No Rate Limits**: Serve unlimited requests
- **Instant Rollback**: Git-based deployment history
- **Version Control**: Assets tracked in git

### Cost

- **Free Tier**: 10 million requests/month included
- **No Database Costs**: No PostgreSQL/D1/KV bills
- **Edge Compute**: Minimal CPU usage (just routing)

## Development

### Build and Deploy

```bash
# Build domain assets
bun run build

# Test locally
bun run dev
# Visit http://localhost:8787/domains

# Deploy to production
bun run deploy:production
```

### Adding New Domains

1. Add domain MDX file: `sites/do/newdomain/index.mdx`
2. Run enrichment: `bun scripts/enrich-domains.ts`
3. Rebuild routes: `bun run build` (in workers/routes)
4. Deploy: `bun run deploy`

### Updating Existing Domains

1. Modify MDX file or re-run enrichment
2. Rebuild routes
3. Deploy

The worker will automatically serve the updated data.

## Integration Examples

### Fetch All Domains

```ts
const response = await fetch('https://routes.do/domains/index.json')
const domains = await response.json()

console.log(`Total domains: ${domains.length}`)
const working = domains.filter(d => d.httpWorking)
console.log(`Working domains: ${working.length}`)
```

### Get Specific Domain

```ts
const response = await fetch('https://routes.do/domains/fetch.do/index.json')
const domain = await response.json()

console.log(`${domain.domain} - ${domain.expectedBehavior}`)
console.log(`Status: ${domain.httpStatus}`)
console.log(`Expires in: ${domain.daysUntilExpiration} days`)
```

### Get Statistics

```ts
const response = await fetch('https://routes.do/domains/stats.json')
const stats = await response.json()

console.log(`Total: ${stats.totalDomains}`)
console.log(`Working: ${stats.byStatus.working}`)
console.log(`Expiring soon: ${stats.expiringSoon}`)
```

### Use in Dashboard

```html
<!DOCTYPE html>
<html>
<body>
  <div id="domains"></div>
  <script>
    fetch('https://routes.do/domains/index.json')
      .then(r => r.json())
      .then(domains => {
        const html = domains
          .filter(d => d.httpWorking)
          .map(d => `<div>${d.domain} - ${d.expectedBehavior}</div>`)
          .join('')
        document.getElementById('domains').innerHTML = html
      })
  </script>
</body>
</html>
```

## CORS Support

All routes include CORS headers for cross-origin access:

```
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization
```

Use from any domain without CORS errors.

## Authentication

The `/api/refresh` endpoint requires authentication:

```bash
curl -X POST https://routes.do/api/refresh \
  -H "Authorization: Bearer $ROUTES_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "source": "github",
    "type": "domain-update"
  }'
```

Set `ROUTES_API_KEY` environment variable via wrangler:

```bash
wrangler secret put ROUTES_API_KEY
```

## Monitoring

### Worker Analytics

View in Cloudflare dashboard:
- Request volume
- Response times
- Error rates
- Geographic distribution

### Asset Analytics

Track:
- Cache hit rates
- Bandwidth usage
- Popular domains
- API vs HTML traffic

## Future Enhancements

### Planned Features

- [ ] Search API (`GET /domains/search?q=fetch`)
- [ ] Filter by status (`GET /domains?status=working`)
- [ ] RSS feed for expiring domains
- [ ] Webhook notifications
- [ ] Historical data (track changes over time)

### Integration Ideas

- Monitor expiring domains in Slack
- Auto-renew critical domains
- Track HTTP status changes
- Alert on nameserver mismatches
- Domain health dashboard

## Related Documentation

- [Domain Enrichment](../../notes/2025-10-04-domain-enrichment.md)
- [Registrar Fetching](../../notes/2025-10-04-registrar-fetch-implementation.md)
- [GitHub Issue #2](https://github.com/dot-do/.do/issues/2)

## Tech Stack

- **Workers Assets** - Static asset serving
- **mdxdb** - MDX database abstraction
- **velite** - MDX validation and processing
- **TypeScript** - Type-safe worker code
- **Bun** - Fast JavaScript runtime

## Dependencies

This worker has no runtime dependencies - it only uses:
- Cloudflare Workers runtime
- Workers Assets binding

Build-time dependencies (for asset generation):
- `@mdxdb/fs` - MDX database abstraction
- `velite` - MDX validation
- `typescript` - Type checking

---

**Generated from:** routes.mdx

**Build command:** `tsx scripts/build-mdx-worker.ts routes.mdx`
